```
G: Business
P: 9096844HWChwc#

P: Srrw@Bs5A3X*


```



```
今日事今日毕：7/4/2025

1. 【√】去30服务器，然后删除web文件就可以了，api就保留。
2. 【√】薪水查看
3. 【√】找回 ServiceNow 的账号，研究
```

```
今日事今日毕：8/4/2025

1. 【x】实现在手机打开PDF
```

```
今日事今日毕：9/4/2025

1. 【√】plan -> 手机浏览器
2. 【】chassis -> pdf文件
3. 【】旧的hsahq 打开
```

```
Open PDF in Viewer
```

### 🔧 你现在的情况：

| 项目版本 | 启动端口 | 防火墙 | 外部能否访问 | 说明                                 |
| -------- | -------- | ------ | ------------ | ------------------------------------ |
| 旧项目   | 4200     | 已注册 | ✅ 可以访问   | 程序监听了 `0.0.0.0`，可以被外部请求 |
| 新项目   | 5200     | 已注册 | ❌ 无法访问   | 程序监听了 `localhost`，只能本机访问 |





```
PowerShell 
netsh advfirewall firewall add rule name="Allow TCP Port 5200" protocol=TCP dir=in localport=5200 action=allow

CMD
netsh advfirewall firewall show rule name="Allow TCP Port 5200"

```



```
启动了，还是打不开8081，

iis里
之前旧的是：http://hongsenghq.ddns.net:8080/web/
我的新的应该是：http://hongsenghq.ddns.net:8081/hsahq/
打不开

type: http
hst name: hongsenghq.ddns.net
port: 8081
Ip address: *

Browse hongsenghq.ddns.net on*:8081(http)
```

```
👌 明白了！你现在的路径是：

makefile
Copy
Edit
C:\inetpub\wwwroot\hsahq
这表示你可能 没有创建一个独立的站点（Site），而是：

➤ 在 Default Web Site（默认网站）底下加了一个虚拟目录（Virtual Directory）或应用程序（Application）。
所以你访问的路径就必须带 /hsahq：

bash
Copy
Edit
http://hongsenghq.ddns.net:8080/hsahq/
⚠️ 而你现在设定了 8081，但如果是挂在 Default Web Site 下，它默认监听的是 80 或 8080，你要用 8081，还得额外配置。

✅ 如果你想用 http://hongsenghq.ddns.net:8081/ 打开：
你需要这样设置：

🔧 正确做法是：
打开 IIS 管理器。

右键左边的 “Sites” > Add Website...

填写信息如下：

字段	输入
Site name	hsahq ✅
Physical path	C:\inetpub\wwwroot\hsahq ✅
Type	http
IP address	* 或 All Unassigned
Port	8081 ✅
Host name	hongsenghq.ddns.net（可填可不填）
添加完成后，右键网站 > 浏览，看是否能在本机打开。

确保 防火墙已放行 8081（你已经做过 👍）

🔍 如果你只是在默认站点下添加了一个目录：
那你访问的就必须是：

bash
Copy
Edit
http://hongsenghq.ddns.net:8080/hsahq/
不是 8081 哦！

你可以确认一下：

左侧的“Sites”下有没有 hsahq 是独立的？

是否真的绑定了 8081？

如果你不确定，可以贴一下截图，或者我可以继续一步一步引导你重新建立站点。
```

```
web
	- 旧的
	- 新的 hsahq
```

```
netsh advfirewall firewall show rule name="Allow TCP Port 5200"



netsh advfirewall firewall add rule name="Allow TCP Port 8081" protocol=TCP dir=in localport=8081 action=allow
netsh advfirewall firewall show rule name="Allow TCP Port 8081"




netsh advfirewall firewall add rule name="Allow TCP Port 8081" protocol=TCP dir=in localport=8081 action=allow
netsh advfirewall firewall show rule name="Allow TCP Port 8081"

netsh advfirewall firewall delete rule name="Allow TCP Port 8081"



```



```
？？

你刚刚说，C:\inetpub\wwwroot\hsahq可能 没有创建一个独立的站点（Site）

http://hongsenghq.ddns.net:8080/hsahq/
？
而你现在设定了 8081，但如果是挂在 Default Web Site 下，它默认监听的是 80 或 8080，你要用 8081，还得额外配置。？？？？

什么意思？？？到底是8080还是8081？？？

我的文件放在C:\inetpub\wwwroot\hsahq的，所以呢？？

在iis是这样的

Sites
- Default Web Site
	- hsahq
	- web
- hsahq
- web
```



```
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const pdfContainerRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [initialPinchDistance, setInitialPinchDistance] = useState(null);
  const [currentScale, setCurrentScale] = useState(1);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Failed to load PDF file: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const downloadPDF = async () => {
    try {
      if (!pdfSource?.uri) return;
      
      if (Platform.OS === 'web') {
        // For web, create a download link
        const link = document.createElement('a');
        link.href = pdfSource.uri;
        link.download = `${plan?.plan_id || 'document'}.pdf`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        return;
      }
      
      // For mobile, download and share
      const downloadPath = `${FileSystem.documentDirectory}${Date.now()}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfSource.uri, downloadPath);
      
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(uri);
      } else {
        alert('Download completed, file saved locally');
      }
    } catch (err) {
      console.error('Download failed', err);
      setError('下载失败');
    }
  };

  const handleTouchStart = (e) => {
    if (e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      setInitialPinchDistance(distance);
    }
  };

  const handleTouchMove = (e) => {
    if (e.touches.length === 2 && initialPinchDistance !== null) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      
      const newScale = (distance / initialPinchDistance) * currentScale;
      setCurrentScale(Math.max(0.5, Math.min(newScale, 3)));
      renderPage(pageNum, pdfDoc, newScale);
    }
  };

  const handleTouchEnd = () => {
    setInitialPinchDistance(null);
  };

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Failed to load PDF.js library');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js library not loaded');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Failed to load PDF: ${err.message}. Path: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      // Set canvas dimensions to match the viewport
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`渲染PDF页面失败: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Loading PDF document...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF path: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>No document available</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF viewer...</Text>
          </View>
        );
      }

      // For web, use iframe for better pinch-zoom support instead of canvas
      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Page {pageNum} of {totalPages}
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="Previous" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="Next" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
            </View>
          </View>
          
          <TouchableOpacity 
            activeOpacity={1} 
            onPress={toggleZoom}
            style={zoomMode ? styles.zoomedCanvasContainer : styles.canvasContainer}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          >
            <canvas 
              ref={canvasRef} 
              style={zoomMode ? styles.zoomedPdfCanvas : styles.pdfCanvas} 
            />
          </TouchableOpacity>
        </View>
      );
    }

    // For native mobile, use react-native-pdf with built-in pinch zoom
    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('Failed to load PDF document');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={zoomMode ? 2 : 1}
        minScale={0.5}
        maxScale={3}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF document...</Text>
          </View>
        )}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
        onTap={() => toggleZoom()}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'Document Viewer'}
        </Text>
        <TouchableOpacity onPress={downloadPDF}>
          <Ionicons name="download" size={24} color={COLORS.white} />
        </TouchableOpacity>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
    touchAction: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
    touchAction: 'none',
  },
});

export default PlanDocument;
```



### 不能显示pdf的， 有download， 放大

```
不能显示pdf的， 有download， 放大

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
  Linking,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [pdfRendered, setPdfRendered] = useState(false);

  // Enable pinch-to-zoom via meta tag
  useEffect(() => {
    if (Platform.OS === 'web') {
      // Set viewport meta tag to allow user scaling
      let viewportMeta = document.querySelector('meta[name=viewport]');
      if (viewportMeta) {
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
      } else {
        viewportMeta = document.createElement('meta');
        viewportMeta.name = 'viewport';
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
        document.head.appendChild(viewportMeta);
      }
    }
  }, []);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Failed to load PDF file: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Failed to load PDF.js library');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js library not loaded');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      // Immediately render the first page
      renderPage(1, pdfDoc_).then(() => {
        setPdfRendered(true);
        setIsLoading(false);
      });
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Failed to load PDF: ${err.message}. Path: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = async (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    try {
      const page = await doc.getPage(num);
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      await page.render(renderContext).promise;
      return true;
    } catch (err) {
      console.error('Error rendering page:', err);
      setError(`Failed to render PDF page: ${err.message}`);
      return false;
    }
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  // Download PDF file
  const downloadPdf = () => {
    if (pdfSource?.uri) {
      if (Platform.OS === 'web') {
        // Open PDF in a new window for download
        window.open(pdfSource.uri, '_blank');
      } else {
        // For mobile devices
        Linking.openURL(pdfSource.uri);
      }
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Loading PDF document...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF path: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>No document available</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF viewer...</Text>
          </View>
        );
      }

      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Page {pageNum} of {totalPages}
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="Previous" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="Next" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
              <Button 
                title="Download" 
                onPress={downloadPdf} 
              />
            </View>
          </View>
          
          {/* Container that supports pinch-to-zoom */}
          <div
            style={{
              width: '100%',
              height: '80%', 
              overflow: 'auto',
              WebkitOverflowScrolling: 'touch',
              touchAction: 'manipulation',
            }}
          >
            <canvas 
              ref={canvasRef} 
              style={{
                maxWidth: '100%',
                touchAction: 'manipulation',
                border: 'none',
              }} 
            />
          </div>
        </View>
      );
    }

    return (
      <View style={styles.mobileContainer}>
        <View style={styles.mobileButtonContainer}>
          <Button title="Download" onPress={downloadPdf} />
        </View>
        <Pdf
          source={pdfSource}
          onLoadComplete={(numberOfPages, filePath) => {
            console.log(`PDF loaded with ${numberOfPages} pages`);
            setTotalPages(numberOfPages);
            setIsLoading(false);
          }}
          onPageChanged={(page, numberOfPages) => {
            setPageNum(page);
            setTotalPages(numberOfPages);
          }}
          onError={(error) => {
            console.log('PDF loading error:', error);
            setError('Failed to load PDF document');
            setIsLoading(false);
          }}
          style={styles.pdf}
          enablePaging={true}
          horizontal={false}
          minScale={0.5}
          maxScale={3}
          renderActivityIndicator={() => (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={COLORS.primary} />
              <Text style={styles.loadingText}>Loading PDF document...</Text>
            </View>
          )}
          onPressLink={(uri) => {
            console.log(`Link pressed: ${uri}`);
          }}
        />
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'Document Viewer'}
        </Text>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  mobileContainer: {
    flex: 1,
    width: '100%',
  },
  mobileButtonContainer: {
    padding: 10,
    alignItems: 'flex-end',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
  },
});

export default PlanDocument;
```

```
const downloadPDF = async () => {
    try {
      if (!pdfSource?.uri) return;
      const downloadPath = `${FileSystem.documentDirectory}${Date.now()}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfSource.uri, downloadPath);
      await Sharing.shareAsync(uri);
    } catch (err) {
      console.error('Download failed', err);
      setError('下载失败');
    }
  };

<View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />
      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{plan?.plan_id || '文档查看器'}</Text>
        <TouchableOpacity onPress={downloadPDF}>
          <Ionicons name="download" size={24} color={COLORS.white} />
        </TouchableOpacity>
      </LinearGradient>
      {renderPdfViewer()}
    </View>
```

有pdf，有下载，（双击，点击不能）

```
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const pdfContainerRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [initialPinchDistance, setInitialPinchDistance] = useState(null);
  const [currentScale, setCurrentScale] = useState(1);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Failed to load PDF file: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const downloadPDF = async () => {
    try {
      if (!pdfSource?.uri) return;
      
      if (Platform.OS === 'web') {
        // For web, create a download link
        const link = document.createElement('a');
        link.href = pdfSource.uri;
        link.download = `${plan?.plan_id || 'document'}.pdf`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        return;
      }
      
      // For mobile, download and share
      const downloadPath = `${FileSystem.documentDirectory}${Date.now()}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfSource.uri, downloadPath);
      
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(uri);
      } else {
        alert('Download completed, file saved locally');
      }
    } catch (err) {
      console.error('Download failed', err);
      setError('下载失败');
    }
  };

  const handleTouchStart = (e) => {
    if (e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      setInitialPinchDistance(distance);
    }
  };

  const handleTouchMove = (e) => {
    if (e.touches.length === 2 && initialPinchDistance !== null) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      
      const newScale = (distance / initialPinchDistance) * currentScale;
      setCurrentScale(Math.max(0.5, Math.min(newScale, 3)));
      renderPage(pageNum, pdfDoc, newScale);
    }
  };

  const handleTouchEnd = () => {
    setInitialPinchDistance(null);
  };

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Failed to load PDF.js library');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js library not loaded');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Failed to load PDF: ${err.message}. Path: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      // Set canvas dimensions to match the viewport
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`渲染PDF页面失败: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Loading PDF document...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF path: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>No document available</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF viewer...</Text>
          </View>
        );
      }

      // For web, use iframe for better pinch-zoom support instead of canvas
      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Page {pageNum} of {totalPages}
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="Previous" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="Next" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
            </View>
          </View>
          
          <TouchableOpacity 
            activeOpacity={1} 
            onPress={toggleZoom}
            style={zoomMode ? styles.zoomedCanvasContainer : styles.canvasContainer}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          >
            <canvas 
              ref={canvasRef} 
              style={zoomMode ? styles.zoomedPdfCanvas : styles.pdfCanvas} 
            />
          </TouchableOpacity>
        </View>
      );
    }

    // For native mobile, use react-native-pdf with built-in pinch zoom
    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('Failed to load PDF document');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={zoomMode ? 2 : 1}
        minScale={0.5}
        maxScale={3}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF document...</Text>
          </View>
        )}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
        onTap={() => toggleZoom()}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'Document Viewer'}
        </Text>
        <TouchableOpacity onPress={downloadPDF}>
          <Ionicons name="download" size={24} color={COLORS.white} />
        </TouchableOpacity>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
    touchAction: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
    touchAction: 'none',
  },
});

export default PlanDocument;
```



### 这个要点击一下才显示pdf

```
这个要点击一下才显示pdf

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`加载PDF文件失败: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('加载PDF.js库失败');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js库未加载');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`加载PDF失败: ${err.message}. 路径: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`渲染PDF页面失败: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>正在加载PDF文档...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF路径: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>没有可用的文档</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>正在加载PDF查看器...</Text>
          </View>
        );
      }

      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              第 {pageNum} 页 / 共 {totalPages} 页
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="上一页" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="下一页" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
              <Button 
                title={zoomMode ? "缩小" : "放大"} 
                onPress={toggleZoom} 
              />
            </View>
          </View>
          
          <TouchableOpacity 
            activeOpacity={1} 
            onPress={toggleZoom}
            style={zoomMode ? styles.zoomedCanvasContainer : styles.canvasContainer}
          >
            <canvas 
              ref={canvasRef} 
              style={zoomMode ? styles.zoomedPdfCanvas : styles.pdfCanvas} 
            />
          </TouchableOpacity>
        </View>
      );
    }

    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('加载PDF文档失败');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={zoomMode ? 2 : 1}
        minScale={0.5}
        maxScale={3}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>正在加载PDF文档...</Text>
          </View>
        )}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
        onTap={() => toggleZoom()}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : '文档查看器'}
        </Text>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
  },
});

export default PlanDocument;
```

### 这个没有pdf，只能下载

```
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`加载PDF文件失败: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  // 为web端添加允许双指缩放的meta标签
  useEffect(() => {
    if (Platform.OS === 'web') {
      // 添加允许用户缩放的meta标签
      let viewportMeta = document.querySelector('meta[name=viewport]');
      if (viewportMeta) {
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
      } else {
        viewportMeta = document.createElement('meta');
        viewportMeta.name = 'viewport';
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
        document.head.appendChild(viewportMeta);
      }
    }
  }, []);

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('加载PDF.js库失败');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js库未加载');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`加载PDF失败: ${err.message}. 路径: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`渲染PDF页面失败: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>正在加载PDF文档...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF路径: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>没有可用的文档</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>正在加载PDF查看器...</Text>
          </View>
        );
      }

      // 网页版支持手势缩放的PDF查看器
      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              第 {pageNum} 页 / 共 {totalPages} 页
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="上一页" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="下一页" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
            </View>
          </View>
          
          {/* 使用iframe直接显示PDF，支持手机浏览器的手势缩放 */}
          <iframe
            src={pdfSource.uri}
            style={{
              width: '100%',
              height: '80%',
              border: 'none',
            }}
            title="PDF Viewer"
            allowFullScreen={true}
          />
          
          {/* 保留canvas作为备选，但现在优先使用iframe */}
          {false && (
            <div 
              style={{
                width: '100%',
                height: '80%',
                overflow: 'auto',
                WebkitOverflowScrolling: 'touch',
                touchAction: 'auto',
              }}
            >
              <canvas 
                ref={canvasRef} 
                style={{
                  maxWidth: '100%',
                  height: 'auto',
                  touchAction: 'auto',
                }} 
              />
            </div>
          )}
        </View>
      );
    }

    // 移动端PDF查看器
    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('加载PDF文档失败');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={1.0}
        minScale={0.5}
        maxScale={5.0}
        enableRTL={false}
        fitPolicy={0}
        spacing={0}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>正在加载PDF文档...</Text>
          </View>
        )}
        enableAnnotationRendering={true}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : '文档查看器'}
        </Text>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
  },
});

export default PlanDocument;
```


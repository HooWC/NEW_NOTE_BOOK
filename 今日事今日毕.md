```
G: Business
P: 9096844HWChwc#

P: Srrw@Bs5A3X*


```



```
‰ªäÊó•‰∫ã‰ªäÊó•ÊØïÔºö7/4/2025

1. „Äê‚àö„ÄëÂéª30ÊúçÂä°Âô®ÔºåÁÑ∂ÂêéÂà†Èô§webÊñá‰ª∂Â∞±ÂèØ‰ª•‰∫ÜÔºåapiÂ∞±‰øùÁïô„ÄÇ
2. „Äê‚àö„ÄëËñ™Ê∞¥Êü•Áúã
3. „Äê‚àö„ÄëÊâæÂõû ServiceNow ÁöÑË¥¶Âè∑ÔºåÁ†îÁ©∂
```

```
‰ªäÊó•‰∫ã‰ªäÊó•ÊØïÔºö8/4/2025

1. „Äêx„ÄëÂÆûÁé∞Âú®ÊâãÊú∫ÊâìÂºÄPDF
```

```
‰ªäÊó•‰∫ã‰ªäÊó•ÊØïÔºö9/4/2025

1. „Äê‚àö„Äëplan -> ÊâãÊú∫ÊµèËßàÂô®
2. „Äê„Äëchassis -> pdfÊñá‰ª∂
3. „Äê„ÄëÊóßÁöÑhsahq ÊâìÂºÄ
```

```
Open PDF in Viewer
```

### üîß ‰Ω†Áé∞Âú®ÁöÑÊÉÖÂÜµÔºö

| È°πÁõÆÁâàÊú¨ | ÂêØÂä®Á´ØÂè£ | Èò≤ÁÅ´Â¢ô | Â§ñÈÉ®ËÉΩÂê¶ËÆøÈóÆ | ËØ¥Êòé                                 |
| -------- | -------- | ------ | ------------ | ------------------------------------ |
| ÊóßÈ°πÁõÆ   | 4200     | Â∑≤Ê≥®ÂÜå | ‚úÖ ÂèØ‰ª•ËÆøÈóÆ   | Á®ãÂ∫èÁõëÂê¨‰∫Ü `0.0.0.0`ÔºåÂèØ‰ª•Ë¢´Â§ñÈÉ®ËØ∑Ê±Ç |
| Êñ∞È°πÁõÆ   | 5200     | Â∑≤Ê≥®ÂÜå | ‚ùå Êó†Ê≥ïËÆøÈóÆ   | Á®ãÂ∫èÁõëÂê¨‰∫Ü `localhost`ÔºåÂè™ËÉΩÊú¨Êú∫ËÆøÈóÆ |





```
PowerShell 
netsh advfirewall firewall add rule name="Allow TCP Port 5200" protocol=TCP dir=in localport=5200 action=allow

CMD
netsh advfirewall firewall show rule name="Allow TCP Port 5200"

```



```
ÂêØÂä®‰∫ÜÔºåËøòÊòØÊâì‰∏çÂºÄ8081Ôºå

iisÈáå
‰πãÂâçÊóßÁöÑÊòØÔºöhttp://hongsenghq.ddns.net:8080/web/
ÊàëÁöÑÊñ∞ÁöÑÂ∫îËØ•ÊòØÔºöhttp://hongsenghq.ddns.net:8081/hsahq/
Êâì‰∏çÂºÄ

type: http
hst name: hongsenghq.ddns.net
port: 8081
Ip address: *

Browse hongsenghq.ddns.net on*:8081(http)
```

```
üëå ÊòéÁôΩ‰∫ÜÔºÅ‰Ω†Áé∞Âú®ÁöÑË∑ØÂæÑÊòØÔºö

makefile
Copy
Edit
C:\inetpub\wwwroot\hsahq
ËøôË°®Á§∫‰Ω†ÂèØËÉΩ Ê≤°ÊúâÂàõÂª∫‰∏Ä‰∏™Áã¨Á´ãÁöÑÁ´ôÁÇπÔºàSiteÔºâÔºåËÄåÊòØÔºö

‚û§ Âú® Default Web SiteÔºàÈªòËÆ§ÁΩëÁ´ôÔºâÂ∫ï‰∏ãÂä†‰∫Ü‰∏Ä‰∏™ËôöÊãüÁõÆÂΩïÔºàVirtual DirectoryÔºâÊàñÂ∫îÁî®Á®ãÂ∫èÔºàApplicationÔºâ„ÄÇ
ÊâÄ‰ª•‰Ω†ËÆøÈóÆÁöÑË∑ØÂæÑÂ∞±ÂøÖÈ°ªÂ∏¶ /hsahqÔºö

bash
Copy
Edit
http://hongsenghq.ddns.net:8080/hsahq/
‚ö†Ô∏è ËÄå‰Ω†Áé∞Âú®ËÆæÂÆö‰∫Ü 8081Ôºå‰ΩÜÂ¶ÇÊûúÊòØÊåÇÂú® Default Web Site ‰∏ãÔºåÂÆÉÈªòËÆ§ÁõëÂê¨ÁöÑÊòØ 80 Êàñ 8080Ôºå‰Ω†Ë¶ÅÁî® 8081ÔºåËøòÂæóÈ¢ùÂ§ñÈÖçÁΩÆ„ÄÇ

‚úÖ Â¶ÇÊûú‰Ω†ÊÉ≥Áî® http://hongsenghq.ddns.net:8081/ ÊâìÂºÄÔºö
‰Ω†ÈúÄË¶ÅËøôÊ†∑ËÆæÁΩÆÔºö

üîß Ê≠£Á°ÆÂÅöÊ≥ïÊòØÔºö
ÊâìÂºÄ IIS ÁÆ°ÁêÜÂô®„ÄÇ

Âè≥ÈîÆÂ∑¶ËæπÁöÑ ‚ÄúSites‚Äù > Add Website...

Â°´ÂÜô‰ø°ÊÅØÂ¶Ç‰∏ãÔºö

Â≠óÊÆµ	ËæìÂÖ•
Site name	hsahq ‚úÖ
Physical path	C:\inetpub\wwwroot\hsahq ‚úÖ
Type	http
IP address	* Êàñ All Unassigned
Port	8081 ‚úÖ
Host name	hongsenghq.ddns.netÔºàÂèØÂ°´ÂèØ‰∏çÂ°´Ôºâ
Ê∑ªÂä†ÂÆåÊàêÂêéÔºåÂè≥ÈîÆÁΩëÁ´ô > ÊµèËßàÔºåÁúãÊòØÂê¶ËÉΩÂú®Êú¨Êú∫ÊâìÂºÄ„ÄÇ

Á°Æ‰øù Èò≤ÁÅ´Â¢ôÂ∑≤ÊîæË°å 8081Ôºà‰Ω†Â∑≤ÁªèÂÅöËøá üëçÔºâ

üîç Â¶ÇÊûú‰Ω†Âè™ÊòØÂú®ÈªòËÆ§Á´ôÁÇπ‰∏ãÊ∑ªÂä†‰∫Ü‰∏Ä‰∏™ÁõÆÂΩïÔºö
ÈÇ£‰Ω†ËÆøÈóÆÁöÑÂ∞±ÂøÖÈ°ªÊòØÔºö

bash
Copy
Edit
http://hongsenghq.ddns.net:8080/hsahq/
‰∏çÊòØ 8081 Âì¶ÔºÅ

‰Ω†ÂèØ‰ª•Á°ÆËÆ§‰∏Ä‰∏ãÔºö

Â∑¶‰æßÁöÑ‚ÄúSites‚Äù‰∏ãÊúâÊ≤°Êúâ hsahq ÊòØÁã¨Á´ãÁöÑÔºü

ÊòØÂê¶ÁúüÁöÑÁªëÂÆö‰∫Ü 8081Ôºü

Â¶ÇÊûú‰Ω†‰∏çÁ°ÆÂÆöÔºåÂèØ‰ª•Ë¥¥‰∏Ä‰∏ãÊà™ÂõæÔºåÊàñËÄÖÊàëÂèØ‰ª•ÁªßÁª≠‰∏ÄÊ≠•‰∏ÄÊ≠•ÂºïÂØº‰Ω†ÈáçÊñ∞Âª∫Á´ãÁ´ôÁÇπ„ÄÇ
```

```
web
	- ÊóßÁöÑ
	- Êñ∞ÁöÑ hsahq
```

```
netsh advfirewall firewall show rule name="Allow TCP Port 5200"



netsh advfirewall firewall add rule name="Allow TCP Port 8081" protocol=TCP dir=in localport=8081 action=allow
netsh advfirewall firewall show rule name="Allow TCP Port 8081"




netsh advfirewall firewall add rule name="Allow TCP Port 8081" protocol=TCP dir=in localport=8081 action=allow
netsh advfirewall firewall show rule name="Allow TCP Port 8081"

netsh advfirewall firewall delete rule name="Allow TCP Port 8081"



```



```
ÔºüÔºü

‰Ω†ÂàöÂàöËØ¥ÔºåC:\inetpub\wwwroot\hsahqÂèØËÉΩ Ê≤°ÊúâÂàõÂª∫‰∏Ä‰∏™Áã¨Á´ãÁöÑÁ´ôÁÇπÔºàSiteÔºâ

http://hongsenghq.ddns.net:8080/hsahq/
Ôºü
ËÄå‰Ω†Áé∞Âú®ËÆæÂÆö‰∫Ü 8081Ôºå‰ΩÜÂ¶ÇÊûúÊòØÊåÇÂú® Default Web Site ‰∏ãÔºåÂÆÉÈªòËÆ§ÁõëÂê¨ÁöÑÊòØ 80 Êàñ 8080Ôºå‰Ω†Ë¶ÅÁî® 8081ÔºåËøòÂæóÈ¢ùÂ§ñÈÖçÁΩÆ„ÄÇÔºüÔºüÔºüÔºü

‰ªÄ‰πàÊÑèÊÄùÔºüÔºüÔºüÂà∞Â∫ïÊòØ8080ËøòÊòØ8081ÔºüÔºüÔºü

ÊàëÁöÑÊñá‰ª∂ÊîæÂú®C:\inetpub\wwwroot\hsahqÁöÑÔºåÊâÄ‰ª•Âë¢ÔºüÔºü

Âú®iisÊòØËøôÊ†∑ÁöÑ

Sites
- Default Web Site
	- hsahq
	- web
- hsahq
- web
```



```
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const pdfContainerRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [initialPinchDistance, setInitialPinchDistance] = useState(null);
  const [currentScale, setCurrentScale] = useState(1);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Failed to load PDF file: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const downloadPDF = async () => {
    try {
      if (!pdfSource?.uri) return;
      
      if (Platform.OS === 'web') {
        // For web, create a download link
        const link = document.createElement('a');
        link.href = pdfSource.uri;
        link.download = `${plan?.plan_id || 'document'}.pdf`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        return;
      }
      
      // For mobile, download and share
      const downloadPath = `${FileSystem.documentDirectory}${Date.now()}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfSource.uri, downloadPath);
      
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(uri);
      } else {
        alert('Download completed, file saved locally');
      }
    } catch (err) {
      console.error('Download failed', err);
      setError('‰∏ãËΩΩÂ§±Ë¥•');
    }
  };

  const handleTouchStart = (e) => {
    if (e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      setInitialPinchDistance(distance);
    }
  };

  const handleTouchMove = (e) => {
    if (e.touches.length === 2 && initialPinchDistance !== null) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      
      const newScale = (distance / initialPinchDistance) * currentScale;
      setCurrentScale(Math.max(0.5, Math.min(newScale, 3)));
      renderPage(pageNum, pdfDoc, newScale);
    }
  };

  const handleTouchEnd = () => {
    setInitialPinchDistance(null);
  };

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Failed to load PDF.js library');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js library not loaded');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Failed to load PDF: ${err.message}. Path: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      // Set canvas dimensions to match the viewport
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`Ê∏≤ÊüìPDFÈ°µÈù¢Â§±Ë¥•: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Loading PDF document...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF path: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>No document available</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF viewer...</Text>
          </View>
        );
      }

      // For web, use iframe for better pinch-zoom support instead of canvas
      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Page {pageNum} of {totalPages}
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="Previous" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="Next" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
            </View>
          </View>
          
          <TouchableOpacity 
            activeOpacity={1} 
            onPress={toggleZoom}
            style={zoomMode ? styles.zoomedCanvasContainer : styles.canvasContainer}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          >
            <canvas 
              ref={canvasRef} 
              style={zoomMode ? styles.zoomedPdfCanvas : styles.pdfCanvas} 
            />
          </TouchableOpacity>
        </View>
      );
    }

    // For native mobile, use react-native-pdf with built-in pinch zoom
    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('Failed to load PDF document');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={zoomMode ? 2 : 1}
        minScale={0.5}
        maxScale={3}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF document...</Text>
          </View>
        )}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
        onTap={() => toggleZoom()}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'Document Viewer'}
        </Text>
        <TouchableOpacity onPress={downloadPDF}>
          <Ionicons name="download" size={24} color={COLORS.white} />
        </TouchableOpacity>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
    touchAction: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
    touchAction: 'none',
  },
});

export default PlanDocument;
```



### ‰∏çËÉΩÊòæÁ§∫pdfÁöÑÔºå ÊúâdownloadÔºå ÊîæÂ§ß

```
‰∏çËÉΩÊòæÁ§∫pdfÁöÑÔºå ÊúâdownloadÔºå ÊîæÂ§ß

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
  Linking,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [pdfRendered, setPdfRendered] = useState(false);

  // Enable pinch-to-zoom via meta tag
  useEffect(() => {
    if (Platform.OS === 'web') {
      // Set viewport meta tag to allow user scaling
      let viewportMeta = document.querySelector('meta[name=viewport]');
      if (viewportMeta) {
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
      } else {
        viewportMeta = document.createElement('meta');
        viewportMeta.name = 'viewport';
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
        document.head.appendChild(viewportMeta);
      }
    }
  }, []);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Failed to load PDF file: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Failed to load PDF.js library');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js library not loaded');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      // Immediately render the first page
      renderPage(1, pdfDoc_).then(() => {
        setPdfRendered(true);
        setIsLoading(false);
      });
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Failed to load PDF: ${err.message}. Path: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = async (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    try {
      const page = await doc.getPage(num);
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      await page.render(renderContext).promise;
      return true;
    } catch (err) {
      console.error('Error rendering page:', err);
      setError(`Failed to render PDF page: ${err.message}`);
      return false;
    }
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  // Download PDF file
  const downloadPdf = () => {
    if (pdfSource?.uri) {
      if (Platform.OS === 'web') {
        // Open PDF in a new window for download
        window.open(pdfSource.uri, '_blank');
      } else {
        // For mobile devices
        Linking.openURL(pdfSource.uri);
      }
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Loading PDF document...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF path: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>No document available</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF viewer...</Text>
          </View>
        );
      }

      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Page {pageNum} of {totalPages}
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="Previous" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="Next" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
              <Button 
                title="Download" 
                onPress={downloadPdf} 
              />
            </View>
          </View>
          
          {/* Container that supports pinch-to-zoom */}
          <div
            style={{
              width: '100%',
              height: '80%', 
              overflow: 'auto',
              WebkitOverflowScrolling: 'touch',
              touchAction: 'manipulation',
            }}
          >
            <canvas 
              ref={canvasRef} 
              style={{
                maxWidth: '100%',
                touchAction: 'manipulation',
                border: 'none',
              }} 
            />
          </div>
        </View>
      );
    }

    return (
      <View style={styles.mobileContainer}>
        <View style={styles.mobileButtonContainer}>
          <Button title="Download" onPress={downloadPdf} />
        </View>
        <Pdf
          source={pdfSource}
          onLoadComplete={(numberOfPages, filePath) => {
            console.log(`PDF loaded with ${numberOfPages} pages`);
            setTotalPages(numberOfPages);
            setIsLoading(false);
          }}
          onPageChanged={(page, numberOfPages) => {
            setPageNum(page);
            setTotalPages(numberOfPages);
          }}
          onError={(error) => {
            console.log('PDF loading error:', error);
            setError('Failed to load PDF document');
            setIsLoading(false);
          }}
          style={styles.pdf}
          enablePaging={true}
          horizontal={false}
          minScale={0.5}
          maxScale={3}
          renderActivityIndicator={() => (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={COLORS.primary} />
              <Text style={styles.loadingText}>Loading PDF document...</Text>
            </View>
          )}
          onPressLink={(uri) => {
            console.log(`Link pressed: ${uri}`);
          }}
        />
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'Document Viewer'}
        </Text>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  mobileContainer: {
    flex: 1,
    width: '100%',
  },
  mobileButtonContainer: {
    padding: 10,
    alignItems: 'flex-end',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
  },
});

export default PlanDocument;
```

```
const downloadPDF = async () => {
    try {
      if (!pdfSource?.uri) return;
      const downloadPath = `${FileSystem.documentDirectory}${Date.now()}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfSource.uri, downloadPath);
      await Sharing.shareAsync(uri);
    } catch (err) {
      console.error('Download failed', err);
      setError('‰∏ãËΩΩÂ§±Ë¥•');
    }
  };

<View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />
      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{plan?.plan_id || 'ÊñáÊ°£Êü•ÁúãÂô®'}</Text>
        <TouchableOpacity onPress={downloadPDF}>
          <Ionicons name="download" size={24} color={COLORS.white} />
        </TouchableOpacity>
      </LinearGradient>
      {renderPdfViewer()}
    </View>
```

ÊúâpdfÔºåÊúâ‰∏ãËΩΩÔºåÔºàÂèåÂáªÔºåÁÇπÂáª‰∏çËÉΩÔºâ

```
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const pdfContainerRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [initialPinchDistance, setInitialPinchDistance] = useState(null);
  const [currentScale, setCurrentScale] = useState(1);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Failed to load PDF file: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const downloadPDF = async () => {
    try {
      if (!pdfSource?.uri) return;
      
      if (Platform.OS === 'web') {
        // For web, create a download link
        const link = document.createElement('a');
        link.href = pdfSource.uri;
        link.download = `${plan?.plan_id || 'document'}.pdf`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        return;
      }
      
      // For mobile, download and share
      const downloadPath = `${FileSystem.documentDirectory}${Date.now()}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfSource.uri, downloadPath);
      
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(uri);
      } else {
        alert('Download completed, file saved locally');
      }
    } catch (err) {
      console.error('Download failed', err);
      setError('‰∏ãËΩΩÂ§±Ë¥•');
    }
  };

  const handleTouchStart = (e) => {
    if (e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      setInitialPinchDistance(distance);
    }
  };

  const handleTouchMove = (e) => {
    if (e.touches.length === 2 && initialPinchDistance !== null) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      
      const newScale = (distance / initialPinchDistance) * currentScale;
      setCurrentScale(Math.max(0.5, Math.min(newScale, 3)));
      renderPage(pageNum, pdfDoc, newScale);
    }
  };

  const handleTouchEnd = () => {
    setInitialPinchDistance(null);
  };

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Failed to load PDF.js library');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.js library not loaded');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Failed to load PDF: ${err.message}. Path: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      // Set canvas dimensions to match the viewport
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`Ê∏≤ÊüìPDFÈ°µÈù¢Â§±Ë¥•: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Loading PDF document...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDF path: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>No document available</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF viewer...</Text>
          </View>
        );
      }

      // For web, use iframe for better pinch-zoom support instead of canvas
      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Page {pageNum} of {totalPages}
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="Previous" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="Next" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
            </View>
          </View>
          
          <TouchableOpacity 
            activeOpacity={1} 
            onPress={toggleZoom}
            style={zoomMode ? styles.zoomedCanvasContainer : styles.canvasContainer}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
          >
            <canvas 
              ref={canvasRef} 
              style={zoomMode ? styles.zoomedPdfCanvas : styles.pdfCanvas} 
            />
          </TouchableOpacity>
        </View>
      );
    }

    // For native mobile, use react-native-pdf with built-in pinch zoom
    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('Failed to load PDF document');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={zoomMode ? 2 : 1}
        minScale={0.5}
        maxScale={3}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Loading PDF document...</Text>
          </View>
        )}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
        onTap={() => toggleZoom()}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'Document Viewer'}
        </Text>
        <TouchableOpacity onPress={downloadPDF}>
          <Ionicons name="download" size={24} color={COLORS.white} />
        </TouchableOpacity>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
    touchAction: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
    touchAction: 'none',
  },
});

export default PlanDocument;
```



### Ëøô‰∏™Ë¶ÅÁÇπÂáª‰∏Ä‰∏ãÊâçÊòæÁ§∫pdf

```
Ëøô‰∏™Ë¶ÅÁÇπÂáª‰∏Ä‰∏ãÊâçÊòæÁ§∫pdf

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Âä†ËΩΩPDFÊñá‰ª∂Â§±Ë¥•: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Âä†ËΩΩPDF.jsÂ∫ìÂ§±Ë¥•');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.jsÂ∫ìÊú™Âä†ËΩΩ');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Âä†ËΩΩPDFÂ§±Ë¥•: ${err.message}. Ë∑ØÂæÑ: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`Ê∏≤ÊüìPDFÈ°µÈù¢Â§±Ë¥•: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Ê≠£Âú®Âä†ËΩΩPDFÊñáÊ°£...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDFË∑ØÂæÑ: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>Ê≤°ÊúâÂèØÁî®ÁöÑÊñáÊ°£</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Ê≠£Âú®Âä†ËΩΩPDFÊü•ÁúãÂô®...</Text>
          </View>
        );
      }

      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Á¨¨ {pageNum} È°µ / ÂÖ± {totalPages} È°µ
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="‰∏ä‰∏ÄÈ°µ" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="‰∏ã‰∏ÄÈ°µ" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
              <Button 
                title={zoomMode ? "Áº©Â∞è" : "ÊîæÂ§ß"} 
                onPress={toggleZoom} 
              />
            </View>
          </View>
          
          <TouchableOpacity 
            activeOpacity={1} 
            onPress={toggleZoom}
            style={zoomMode ? styles.zoomedCanvasContainer : styles.canvasContainer}
          >
            <canvas 
              ref={canvasRef} 
              style={zoomMode ? styles.zoomedPdfCanvas : styles.pdfCanvas} 
            />
          </TouchableOpacity>
        </View>
      );
    }

    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('Âä†ËΩΩPDFÊñáÊ°£Â§±Ë¥•');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={zoomMode ? 2 : 1}
        minScale={0.5}
        maxScale={3}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Ê≠£Âú®Âä†ËΩΩPDFÊñáÊ°£...</Text>
          </View>
        )}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
        onTap={() => toggleZoom()}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'ÊñáÊ°£Êü•ÁúãÂô®'}
        </Text>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
  },
});

export default PlanDocument;
```

### Ëøô‰∏™Ê≤°ÊúâpdfÔºåÂè™ËÉΩ‰∏ãËΩΩ

```
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Platform,
  Dimensions,
  Button,
  Modal,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS, SPACING, SIZES, SHADOWS } from '../../constants/theme';

// Import PDF viewer for mobile
let Pdf;
if (Platform.OS !== 'web') {
  Pdf = require('react-native-pdf').default;
}

const PlanDocument = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { plan } = route.params;
  const [pdfSource, setPdfSource] = useState(null);
  const [error, setError] = useState(null);
  // For web PDF.js viewer
  const canvasRef = useRef(null);
  const [pageNum, setPageNum] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [pdfJsLoaded, setPdfJsLoaded] = useState(false);
  const [zoomMode, setZoomMode] = useState(false);
  const [scale, setScale] = useState(1);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    try {
      if (plan && plan.picloc) {
        setIsLoading(true);
        let newPath = plan.picloc.replace('Y:\\', 'plan/').replace(/\\/g, '/');
        
        if (Platform.OS === 'web') {
          newPath = `${newPath}`;
          newPath = encodeURI(newPath);
        }
        
        console.log('PDF path:', newPath);
        setPdfSource({ uri: newPath, cache: true });
        
        if (Platform.OS === 'web') {
          loadPDFJS(newPath);
        }
      }
    } catch (err) {
      console.error('Error setting PDF source:', err);
      setError(`Âä†ËΩΩPDFÊñá‰ª∂Â§±Ë¥•: ${err.message}`);
      setIsLoading(false);
    }
  }, [plan]);

  // ‰∏∫webÁ´ØÊ∑ªÂä†ÂÖÅËÆ∏ÂèåÊåáÁº©ÊîæÁöÑmetaÊ†áÁ≠æ
  useEffect(() => {
    if (Platform.OS === 'web') {
      // Ê∑ªÂä†ÂÖÅËÆ∏Áî®Êà∑Áº©ÊîæÁöÑmetaÊ†áÁ≠æ
      let viewportMeta = document.querySelector('meta[name=viewport]');
      if (viewportMeta) {
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
      } else {
        viewportMeta = document.createElement('meta');
        viewportMeta.name = 'viewport';
        viewportMeta.content = 'width=device-width, initial-scale=1, maximum-scale=5.0, user-scalable=yes';
        document.head.appendChild(viewportMeta);
      }
    }
  }, []);

  const loadPDFJS = (pdfUrl) => {
    if (Platform.OS === 'web' && typeof window !== 'undefined') {
      if (window.pdfjsLib) {
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
      script.onload = () => {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        setPdfJsLoaded(true);
        initPDF(pdfUrl);
      };
      script.onerror = () => {
        setError('Âä†ËΩΩPDF.jsÂ∫ìÂ§±Ë¥•');
        setIsLoading(false);
      };
      document.head.appendChild(script);
    }
  };

  const initPDF = (url) => {
    if (!window.pdfjsLib) {
      setError('PDF.jsÂ∫ìÊú™Âä†ËΩΩ');
      setIsLoading(false);
      return;
    }

    const loadingTask = window.pdfjsLib.getDocument({
      url: url,
      withCredentials: false,
    });

    loadingTask.promise.then(pdfDoc_ => {
      setPdfDoc(pdfDoc_);
      setTotalPages(pdfDoc_.numPages);
      renderPage(1, pdfDoc_);
      setIsLoading(false);
    }).catch(err => {
      console.error('Error loading PDF:', err);
      setError(`Âä†ËΩΩPDFÂ§±Ë¥•: ${err.message}. Ë∑ØÂæÑ: ${url}`);
      setIsLoading(false);
    });
  };

  const renderPage = (num, doc = pdfDoc, customScale = null) => {
    if (!doc || !canvasRef.current) return;
    
    doc.getPage(num).then(page => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const currentScale = customScale || Math.min(1.5, window.innerWidth / page.getViewport({ scale: 1 }).width);
      const viewport = page.getViewport({ scale: currentScale });
      
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      
      const renderContext = {
        canvasContext: ctx,
        viewport
      };
      
      page.render(renderContext);
    }).catch(err => {
      console.error('Error rendering page:', err);
      setError(`Ê∏≤ÊüìPDFÈ°µÈù¢Â§±Ë¥•: ${err.message}`);
    });
  };

  const prevPage = () => {
    if (pageNum <= 1) return;
    setPageNum(prev => {
      const newPage = prev - 1;
      renderPage(newPage);
      return newPage;
    });
  };
  
  const nextPage = () => {
    if (pageNum >= totalPages) return;
    setPageNum(prev => {
      const newPage = prev + 1;
      renderPage(newPage);
      return newPage;
    });
  };

  const toggleZoom = () => {
    if (zoomMode) {
      setZoomMode(false);
      setScale(1);
      renderPage(pageNum, pdfDoc, 1);
    } else {
      setZoomMode(true);
      setScale(2);
      renderPage(pageNum, pdfDoc, 2);
    }
  };

  const renderPdfViewer = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingText}>Ê≠£Âú®Âä†ËΩΩPDFÊñáÊ°£...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.errorText}>{error}</Text>
          <Text style={styles.errorText}>PDFË∑ØÂæÑ: {pdfSource?.uri}</Text>
        </View>
      );
    }

    if (!pdfSource) {
      return (
        <View style={styles.noDocumentContainer}>
          <Text style={styles.noDocumentText}>Ê≤°ÊúâÂèØÁî®ÁöÑÊñáÊ°£</Text>
        </View>
      );
    }

    if (Platform.OS === 'web') {
      if (!pdfJsLoaded) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Ê≠£Âú®Âä†ËΩΩPDFÊü•ÁúãÂô®...</Text>
          </View>
        );
      }

      // ÁΩëÈ°µÁâàÊîØÊåÅÊâãÂäøÁº©ÊîæÁöÑPDFÊü•ÁúãÂô®
      return (
        <View style={styles.webPdfContainer}>
          <View style={styles.pdfControls}>
            <Text style={styles.pageInfo}>
              Á¨¨ {pageNum} È°µ / ÂÖ± {totalPages} È°µ
            </Text>
            <View style={styles.buttonContainer}>
              <Button 
                title="‰∏ä‰∏ÄÈ°µ" 
                onPress={prevPage} 
                disabled={pageNum <= 1} 
              />
              <Button 
                title="‰∏ã‰∏ÄÈ°µ" 
                onPress={nextPage} 
                disabled={pageNum >= totalPages} 
              />
            </View>
          </View>
          
          {/* ‰ΩøÁî®iframeÁõ¥Êé•ÊòæÁ§∫PDFÔºåÊîØÊåÅÊâãÊú∫ÊµèËßàÂô®ÁöÑÊâãÂäøÁº©Êîæ */}
          <iframe
            src={pdfSource.uri}
            style={{
              width: '100%',
              height: '80%',
              border: 'none',
            }}
            title="PDF Viewer"
            allowFullScreen={true}
          />
          
          {/* ‰øùÁïôcanvas‰Ωú‰∏∫Â§áÈÄâÔºå‰ΩÜÁé∞Âú®‰ºòÂÖà‰ΩøÁî®iframe */}
          {false && (
            <div 
              style={{
                width: '100%',
                height: '80%',
                overflow: 'auto',
                WebkitOverflowScrolling: 'touch',
                touchAction: 'auto',
              }}
            >
              <canvas 
                ref={canvasRef} 
                style={{
                  maxWidth: '100%',
                  height: 'auto',
                  touchAction: 'auto',
                }} 
              />
            </div>
          )}
        </View>
      );
    }

    // ÁßªÂä®Á´ØPDFÊü•ÁúãÂô®
    return (
      <Pdf
        source={pdfSource}
        onLoadComplete={(numberOfPages, filePath) => {
          console.log(`PDF loaded with ${numberOfPages} pages`);
          setTotalPages(numberOfPages);
          setIsLoading(false);
        }}
        onPageChanged={(page, numberOfPages) => {
          setPageNum(page);
          setTotalPages(numberOfPages);
        }}
        onError={(error) => {
          console.log('PDF loading error:', error);
          setError('Âä†ËΩΩPDFÊñáÊ°£Â§±Ë¥•');
          setIsLoading(false);
        }}
        style={styles.pdf}
        enablePaging={true}
        horizontal={false}
        scale={1.0}
        minScale={0.5}
        maxScale={5.0}
        enableRTL={false}
        fitPolicy={0}
        spacing={0}
        renderActivityIndicator={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={styles.loadingText}>Ê≠£Âú®Âä†ËΩΩPDFÊñáÊ°£...</Text>
          </View>
        )}
        enableAnnotationRendering={true}
        onPressLink={(uri) => {
          console.log(`Link pressed: ${uri}`);
        }}
      />
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#0F172A" />

      <LinearGradient
        colors={['#0F172A', '#334155']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.header}
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={COLORS.white} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>
          {plan && plan.plan_id ? plan.plan_id : 'ÊñáÊ°£Êü•ÁúãÂô®'}
        </Text>
      </LinearGradient>

      <View style={styles.pdfContainer}>
        {renderPdfViewer()}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: SPACING.md,
    ...SHADOWS.medium,
  },
  backButton: {
    marginRight: SPACING.sm,
    padding: SPACING.xs,
  },
  headerTitle: {
    fontSize: SIZES.large,
    fontWeight: 'bold',
    color: COLORS.white,
    flex: 1,
  },
  pdfContainer: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    width: '100%',
  },
  pdf: {
    flex: 1,
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
    backgroundColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: SIZES.medium,
    color: COLORS.primary,
  },
  noDocumentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noDocumentText: {
    fontSize: SIZES.medium,
    color: COLORS.gray,
  },
  errorText: {
    fontSize: SIZES.medium,
    color: 'red',
  },
  webPdfContainer: {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
  },
  pdfControls: {
    padding: 10,
    marginBottom: 10,
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  pageInfo: {
    fontSize: 16,
    fontWeight: 'bold',
    marginHorizontal: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  canvasContainer: {
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  zoomedCanvasContainer: {
    width: '100%',
    height: '100%',
    overflow: 'scroll',
  },
  pdfCanvas: {
    maxWidth: '100%',
    border: 'none',
  },
  zoomedPdfCanvas: {
    border: 'none',
  },
});

export default PlanDocument;
```

